Require Import UniMath.Algebra.Monoids.
Require Import UniMath.Algebra.RigsAndRings.
Require Import UniMath.MoreFoundations.All.
Require Import UniMath.Foundations.All.
Require Import UniMath.Algebra.RigsAndRings.Ideals.
Require Import UniMath.Foundations.Propositions.
Require Import UniMath.Combinatorics.StandardFiniteSets.

(* Coercing ideals *)
Definition lideal_to_subabmonoid {X : rig} : lideal X → subabmonoid (rigaddabmonoid X) := pr1.
Coercion lideal_to_subabmonoid : lideal >-> subabmonoid.

Definition the_intersection_submonoid
           {X : monoid} {I : UU} (S : I -> submonoid X) : submonoid X
  := (subtype_intersection S,, intersection_submonoid S (λ x, pr2 (S x))).

(* Monoid generated by a subset *)
Definition monoid_gen (X : monoid) (S : hsubtype X) : submonoid X :=
  the_intersection_submonoid (λ (B : ∑ (C : submonoid X), (∏ (x : X), S x → C x)), pr1 B).

(* Localization at a subset *)
Definition abmonoid_loc (X : abmonoid) (S : hsubtype X) : abmonoid :=
  abmonoidfrac X (monoid_gen X S).

Open Scope ring.

Lemma intersection_lideal
      {R : rig} {I : UU} (S : I -> lideal R):
  is_lideal (the_intersection_submonoid S).
Proof.
  intros r s.
  intro p.
  intro x.
  apply (pr2 (S x) r s (p x)).
Qed.

Definition the_intersection_lideal
           {R : rig} {I : UU} (S : I -> lideal R): lideal R
  := (the_intersection_submonoid S,, intersection_lideal S).

Definition ideal_gen {X : rig} (S : hsubtype X) : lideal X :=
  the_intersection_lideal (λ (B : ∑ (C : lideal X), ∏ (x : X), S x → pr1 C x), pr1 B).

Open Scope rig_scope.

Definition lideal_is_everything {X : rig} (l : lideal X) : UU := ∏ x : X, l x.
Definition lideal_has_one {X : rig} (l : lideal X) : UU := l 1.

Lemma lideal_is_everything_implies_has_one :  ∏ (R : rig), ∏ (l : lideal R),  lideal_is_everything l → lideal_has_one l.
Proof.
  intros R l.
  exact (λ ie, ie 1).
Qed.

Lemma lideal_has_one_implies_is_everything :  ∏ (R : rig), ∏ (l : lideal R),  lideal_has_one l → lideal_is_everything l.
Proof.
intros R l has_1.
     intro x.
     unfold lideal in l.
     assert ((x * 1) = x).
     apply rigrunax2.
     pose (bla:= (pr2 l) x 1 has_1).
     rewrite X in bla.
    exact bla.
Qed.


(*-- idea of the following def.: a family of localizations R-->R[S_i^{-1}] is completely determined by the S_i. Whether it is a covering can also be determined purely in terms of the S_i. --*)
Definition zariski_cover (X : rig) := ∑ I : UU, ∑ S : I → hsubtype X, lideal_has_one (ideal_gen (subtype_union S)).
(*-- for testing the sheaf condition later we will need the localization morphisms...  --*)

Definition generated_twobinopeqrel_hrel {X : setwith2binop} (R : hrel X) : hrel X :=
  λ x x', ∀ (R' : twobinopeqrel X), himpl (∏ y z, R y z → R' y z) (R' x x').

Lemma istwobinophrel_generated_binopeqrel {X : setwith2binop} (R : hrel X) :
  is2binophrel (generated_twobinopeqrel_hrel R).
Proof.
  apply dirprodpair.
  - apply dirprodpair.
    + intros a b c genRab R' RimpR'.
      apply (pr1 (pr1 (pr2 R'))).
      exact (genRab R' RimpR').
    + intros a b c genRab R' RimpR'.
      apply (pr2 (pr1 (pr2 R'))).
      exact (genRab R' RimpR').
  - apply dirprodpair.
    + intros a b c genRab R' RimpR'.
      apply (pr1 (pr2 (pr2 R'))).
      exact (genRab R' RimpR').
    + intros a b c genRab R' RimpR'.
      apply (pr2 (pr2 (pr2 R'))).
      exact (genRab R' RimpR').
Defined.

Lemma iseqrel_generated_twobinopeqrel {X : setwith2binop} (R : hrel X) :
  iseqrel (generated_twobinopeqrel_hrel R).
Proof.
  use iseqrelconstr.
  - intros x1 x2 x3 H1 H2 R' HR. eapply eqreltrans.
    + exact (H1 R' HR).
    + exact (H2 R' HR).
  - intros x R' HR. apply eqrelrefl.
  - intros x1 x2 H R' HR. apply eqrelsymm. exact (H R' HR).
Defined.

Print twobinopeqrel.
Print eqrelpair.

Definition generated_twobinopeqrel {X : setwith2binop} (R : hrel X) : twobinopeqrel X :=
  twobinopeqrelpair (eqrelpair (generated_twobinopeqrel_hrel R) (iseqrel_generated_twobinopeqrel R))
                    (istwobinophrel_generated_binopeqrel R).

(*-- polynomial rings --*)

Section Poly.

  Context {R : commring}.

  Definition Polynomial_Type : UU := ∑ (a:nat → R) , ∃ n, ∏ k, k>n → a k = 0%ring.

  Definition zero_function : (nat → R) := (λ n, 0%ring).

Lemma witness_that_zero_function_is_eventually_zero : ∑ n, ∏ k, k>n → zero_function k = 0%ring.
Proof.
  exists 0%nat.
  intros.
  reflexivity. (* or apply idpath *)
Defined.

Definition zero_Polynomial : Polynomial_Type :=
  (zero_function,, hinhpr  witness_that_zero_function_is_eventually_zero).


(*-- alternative version --*)
Definition zero_Polynomial_bis : Polynomial_Type.
Proof.
  unfold Polynomial_Type.
  use tpair.
  - exact (λ n, 0%ring).
  - cbn.
    apply hinhpr.
    exists 0%nat.
    intros.
    reflexivity. (* or "apply idpath" *)
Defined.


(*-- Arithmetical lemmas needed to show that pointwise addition of eventually zero sequences is eventually zero --*)
Lemma max_gt1 (m n k:nat) : natgth k (max m n) → natgth k m.
Admitted.

Lemma max_gt2 (m n k:nat) : natgth k (max m n) → natgth k n.
Admitted.

(*-- pointwise addition of sequences  *)
Definition sequence_sum (a b : nat → R) : nat → R := λ n, a n + b n.

Lemma sequence_sum_is_assoc : isassoc sequence_sum.
Proof.
  unfold isassoc.
  intros.
  apply funextfun.
  intro n.
  unfold sequence_sum.
  apply ringassoc1.
Qed.

Lemma zero_function_is_neutral : islunit sequence_sum zero_function.
Proof.
  unfold islunit.
  intros.
  apply funextfun.
  unfold homotsec.
  intro n.
  unfold sequence_sum.
  change ((0 + x n)%ring = x n).
  apply ringlunax1.
Qed.

Lemma sequence_sum_is_comm : iscomm sequence_sum.
Proof.
  unfold iscomm.
  intros.
  apply funextfun.
  intro n.
  unfold sequence_sum.
  apply ringcomm1.
Qed.

(*-- addition of polynomials --*)

Definition Eventually_zero_proof_addition (a b : nat → R) :  (∑ n:nat, ∏ k:nat, k>n → a k = 0%ring) → (∑ n:nat, ∏ k:nat, k>n → b k = 0%ring) → (∑ n:nat, ∏ k:nat, k>n → sequence_sum a b k = 0%ring).
Proof.
  intros p q.
  exists (max (pr1 p) (pr1 q)).
  intros k X.
  induction p as (s, hs).
  induction q as (t, ht).
  change (hProptoType (k > max s t)) in X.
  change (a k + b k = 0%ring).
  rewrite (hs k (max_gt1 s t k X)).
  rewrite (ht k (max_gt2 s t k X)).
  apply ringlunax1.
Defined.

Definition Polynomial_addition : Polynomial_Type → Polynomial_Type → Polynomial_Type.
Proof.
  intros p q.
  unfold Polynomial_Type.
  use tpair.
  - exact (sequence_sum (pr1 p) (pr1 q)).
  - simpl.
    apply (hinhfun2 (Eventually_zero_proof_addition (pr1 p) (pr1 q)) (pr2 p) (pr2 q)).
Defined.

 (* for an equality of polynomials it is sufficient to know the equality of the sequences: *)
Lemma polynomial_eq (p q : Polynomial_Type) : pr1 p = pr1 q → p = q.
Proof.
  intros H.
  apply subtypeEquality'.
  - exact H.
  - apply propproperty.
Defined.

Lemma add_is_assoc : isassoc Polynomial_addition.
Proof.
  unfold isassoc.
  intros.
  apply polynomial_eq.
  cbn.
  apply sequence_sum_is_assoc.
Defined.

Lemma zero_Polynomial_is_neutral : islunit Polynomial_addition zero_Polynomial.
Proof.
  unfold islunit.
  intros.
  apply polynomial_eq.
  cbn.
  apply zero_function_is_neutral.
Defined.


Lemma add_is_comm : iscomm Polynomial_addition.
Proof.
  unfold iscomm.
  intros.
  apply polynomial_eq.
  cbn.
  apply sequence_sum_is_comm.
Defined.

(*-- induction principle for polynomials --*)

Definition sequence_shift (f:nat → R) (a0 : R) : nat → R.
Proof.
  intro i.
  induction i as [|j _].
  - exact a0.
  - exact (f j).
Defined.

Definition Eventually_zero_shift (b : nat → R) (a0 : R) :
  (∑ n:nat, ∏ k:nat, k>n → b k = 0%ring) → (∑ n:nat, ∏ k:nat, k>n → sequence_shift b a0 k = 0%ring).
Proof.
  intro p.
  use tpair.
  - exact (S (pr1 p)).
  - intros k greater.
    induction k as [| l].
    + induction (negnatgth0n _ greater).
    + simpl.
      change (hProptoType (l > pr1 p)) in greater.
      apply (pr2 p l greater).
Defined.

(* Definition polynomial_shift_new (a0 : R) : Polynomial_Type → Polynomial_Type. *)
(* Proof. *)
(*   intro a. *)
(*   use tpair. *)
(*   - exact (sequence_shift (pr1 a) a0). *)
(*   - simpl. *)
(*     apply (pr2 a *)
(*                (ishinh *)
(*                   (∑ n : nat, *)
(*                          ∏ k : nat, natgtb k n = true → sequence_shift (pr1 a) a0 k = 0%ring))). *)
(*     intro thing. *)
(*     exact (hinhpr (Eventually_zero_shift (pr1 a) a0 thing)). *)
(* Defined. *)

Definition polynomial_shift (a0 : R) : Polynomial_Type → Polynomial_Type.
Proof.
  intro a.
  use tpair.
  - exact (sequence_shift (pr1 a) a0).
  - exact (hinhfun (Eventually_zero_shift (pr1 a) a0) (pr2 a)).
Defined.

Definition zeroth_coefficient : Polynomial_Type → R := (λ p, (pr1 p 0%nat)).



Definition constant_sequence (a : R) : nat → R.
Proof.
 intro n.
  induction n as [|k].
  + exact (a).
  + exact (0%ring).
Defined.

Lemma witness_that_constant_polynomial_is_eventually_zero (a : R) : ∑ n, ∏ k, k>n → constant_sequence a k = 0%ring.
Proof.
  exists 1%nat.
  intros.
  induction k as [|j _].
  - cbn in X.
    apply nopathsfalsetotrue in X.
    induction X.
  - cbn.
    reflexivity.
Qed.

Definition constant_polynomial (a : R) : Polynomial_Type   := (constant_sequence a,, hinhpr (witness_that_constant_polynomial_is_eventually_zero a)).

Definition sequence_shift_down (f:nat → R) : nat → R :=(λ n, f (S n)).

Definition Eventually_zero_shift_down (b : nat → R) :
  (∑ n:nat, ∏ k:nat, k>n → b k = 0%ring) → (∑ n:nat, ∏ k:nat, k>n → sequence_shift_down b k = 0%ring).
Proof.
  intro p.
  use tpair.
  - exact (pr1 p).
  - intros k greater.
    exact (pr2 p (S k) (natgthtogths k (pr1 p) greater)).
Defined.

Definition polynomial_shift_down : Polynomial_Type → Polynomial_Type.
Proof.
  intro a.
  use tpair.
  - exact (sequence_shift_down (pr1 a)).
  - exact (hinhfun (Eventually_zero_shift_down (pr1 a) ) (pr2 a)).
Defined.


Lemma every_sequence_is_zeroth_coefficient_plus_rest (p: nat → R) : (p = (sequence_shift (sequence_shift_down p) (p 0%nat) )) .
Proof.
apply funextfun.
intro n.
induction n as [|j _].
- compute.
  reflexivity.
- compute.
  reflexivity.
Qed.


Lemma every_poly_is_zeroth_coefficient_plus_rest (p: Polynomial_Type) : (p = (polynomial_shift (zeroth_coefficient p) (polynomial_shift_down p) )) .
Proof.
apply subtypeEquality'.
- exact (every_sequence_is_zeroth_coefficient_plus_rest (pr1 p)).
- simpl.
  apply isapropishinh.
Qed.


Definition sequence_and_bound : UU := ∑ (a : nat → R),  (∑ n:nat, ∏ k:nat, k>n → a k = 0%ring).

Definition sequence_and_bound_shift (a0 : R) : sequence_and_bound → sequence_and_bound.
Proof.
  intro a.
  use tpair.
  - exact (sequence_shift (pr1 a) a0).
  - exact ((Eventually_zero_shift (pr1 a) a0) (pr2 a)).
Defined.

(*-- messy part begins here --*)

Lemma every_sequence_and_bound_is_zeroth_coefficient_plus_rest (p: sequence_and_bound) : (p = (polynomial_shift (zeroth_coefficient p) (polynomial_shift_down p) )) .
Proof.
apply subtypeEquality'.
- exact (every_sequence_is_zeroth_coefficient_plus_rest (pr1 p)).
- (* start case distinction; lower the bound if possible*).
Qed.


(*-- prove the following by induction on the bound --*)

Definition sequence_and_bound_induction (P : sequence_and_bound → UU) (base_case : P((zero_function,, witness_that_zero_function_is_eventually_zero))) (ind_step : ∏ (p : sequence_and_bound), ∏ (a : R),  P(p) → P(sequence_and_bound_shift a p)) : (∏ (q : sequence_and_bound), P(q)).
Proof.
intro q.

(*-- hpropify the previous definition  --*)

Definition poly_induction (P : Polynomial_Type → hProp) (base_case : P(zero_Polynomial)) (ind_step : ∏ (p : Polynomial_Type), ∏ (a : R), P(p) → P(polynomial_shift a p)) : (∏ (q : Polynomial_Type), P(q)).
Proof.
  intro q.
  pose (every_poly_is_zeroth_coefficient_plus_rest q) as g.

  rewrite every_poly_is_zeroth_coefficient_plus_rest.

  change (polynomial_shift a p) in q using every_poly_is_zeroth_coefficient_plus_rest.


(*-- convolution product of sequences --*)
Definition sequence_product (a b : nat → R) : nat → R :=
  (λ n, foldleft 0%ring op1%ring (λ kp: stn n, (a (pr1 kp) * (b (n - pr1 kp)%nat))%ring)).

Lemma sequence_product_is_assoc : isassoc sequence_product.
Proof.
  unfold isassoc.
  intros.
  apply funextfun.
  intro n.
  unfold sequence_product. (* try "compute." at this point: the outcome is impressive *)


Qed.




(* arithmetical lemmas used to prove that the sequence product induces a product of polynomials*)
  Lemma sum_gt1 (m n k:nat) : natgth k (m + n) → natgth k m.
  Admitted.

  Lemma sum_gt2 (m n k:nat) : natgth k (m + n) → natgth k n.
  Admitted.

  Lemma gt_or_lt_lem (m n r k : nat) (p : r > m + n) (q : k < r) : (k > m) ⨿ (r - k > n).
  Admitted.

  Lemma sum_of_zeros (n : nat) (s : stn n → R) (allz : ∏ k : stn n, s k = 0%ring) :
    foldleft 0%ring op1%ring s = 0%ring.
  Admitted.

  Definition Eventually_zero_proof_multiplication (a b : nat → R) : (∑ n:nat, ∏ k:nat, k>n → a k = 0%ring) → (∑ n:nat, ∏ k:nat, k>n → b k = 0%ring) → (∑ n:nat, ∏ k:nat, k>n → sequence_product a b k = 0%ring).
  Proof.
    intros p q.
    exists (pr1 p + pr1 q)%nat.
    intros k X.
    induction p as (s, hs).
    induction q as (t, ht).
    change (hProptoType (k > s + t)) in X.
    unfold sequence_product.
    assert (allzero : ∏ kp : stn k, (a (pr1 kp) * b (k - pr1 kp)%nat) = 0%ring).
    {
      intro lp.
      induction lp as (l, lpf).
      induction (gt_or_lt_lem s t k l X lpf).
      - change ((a l * b (k - l)%nat)%ring = 0%ring).
        rewrite (hs l a0).
        rewrite ringmult0x.
        apply idpath.
      - change ((a l * b (k - l)%nat)%ring = 0%ring).
        rewrite (ht (k - l)%nat b0).
        rewrite ringmultx0.
        apply idpath.
    }
    rewrite (sum_of_zeros k (λ kp : (⟦ k ⟧)%stn, (a (pr1 kp) * b (k - pr1 kp)%nat)%ring) allzero).
    apply idpath.
  Defined.

  Definition Polynomial_multiplication : Polynomial_Type → Polynomial_Type → Polynomial_Type.
  Proof.
    intros p q.
    unfold Polynomial_Type.
    use tpair.
    - exact (sequence_product (pr1 p) (pr1 q)).
    - simpl.
      apply (hinhfun2 (Eventually_zero_proof_multiplication (pr1 p) (pr1 q)) (pr2 p) (pr2 q)).
  Defined.





  (* To do: R[x] as a commring, iterating this to get R[x_1,...,x_n]   *)

End Poly.

(* To do: fin. gen. ideals, fin. pres. rings (better: R-algebras...), Zariski sheaves, schemes  *)